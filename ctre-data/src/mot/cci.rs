//! Motor controller enums defined in the Phoenix CCI headers.
#![allow(non_camel_case_types, non_upper_case_globals)]

/* automatically generated by rust-bindgen, ish */

#[repr(i32)]
/// How to interpret a demand value.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum DemandType {
    /// Ignore the demand value and apply neutral/no-change.
    Neutral = 0,
    /**
     * When closed-looping, set the target of the aux PID loop to the demand value.
     *
     * When following, follow the processed output of the combined
     * primary/aux PID output.  The demand value is ignored.
     * Although it is much cleaner to use the 2-param follow() in such cases.
     */
    AuxPID = 1,
    /// Simply add to the output
    ArbitraryFeedForward = 2,
}

impl FeedbackDevice {
    /**
     * CTR mag encoder configured in absolute, is the same
     * as a PWM sensor.
     */
    pub const CTRE_MagEncoder_Absolute: FeedbackDevice = FeedbackDevice::PulseWidthEncodedPosition;
    /**
     * CTR mag encoder configured in relative, is the same
     * as an quadrature encoder sensor.
     */
    pub const CTRE_MagEncoder_Relative: FeedbackDevice = FeedbackDevice::QuadEncoder;
}
#[repr(i32)]
/// Choose the feedback device for a motor controller.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "num", derive(FromPrimitive))]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub enum FeedbackDevice {
    // NOTE: None removed as it doesn't exist in firmware
    /// Quadrature encoder
    QuadEncoder = 0,
    /// Analog potentiometer/encoder
    Analog = 2,
    /// Tachometer
    Tachometer = 4,
    /**
     * CTRE Mag Encoder in Relative mode or
     * any other device that uses PWM to encode its output
     */
    PulseWidthEncodedPosition = 8,
    /// Sum0 + Sum1
    SensorSum = 9,
    /// Diff0 - Diff1
    SensorDifference = 10,
    /// Sensor configured in RemoteFilter0
    RemoteSensor0 = 11,
    /// Sensor configured in RemoteFilter1
    RemoteSensor1 = 12,
    /// Motor Controller will fake a sensor based on applied motor output.
    SoftwareEmulatedSensor = 15,
}
#[repr(i32)]
/// Choose the remote feedback device for a motor controller
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "num", derive(FromPrimitive))]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub enum RemoteFeedbackDevice {
    // NOTE: None removed as it doesn't exist in firmware
    /// Factory default setting for non-enhanced motor controllers
    FactoryDefaultOff = 0,
    /// Use Sum0 + Sum1
    SensorSum = 9,
    /// Use Diff0 - Diff1
    SensorDifference = 10,
    /**
     * Use the sensor configured
     * in filter0
     */
    RemoteSensor0 = 11,
    /**
     * Use the sensor configured
     * in filter1
     */
    RemoteSensor1 = 12,
    /// Motor Controller will fake a sensor based on applied motor output.
    SoftwareEmulatedSensor = 15,
}

/// Choose the type of follower
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum FollowerType {
    /// Follow the PercentOutput the master is using
    PercentOutput = 0,
    /**
     * Follow the auxiliary output the master is
     * calculating. Used for 2-axis control.
     * This typically means apply PID0 - PID1 from master.
     */
    AuxOutput1,
}

#[repr(i32)]
/// Limit switch source enum
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "num", derive(FromPrimitive))]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub enum LimitSwitchSource {
    /// Limit switch directly connected to motor controller
    FeedbackConnector = 0,
    /// Use Limit switch connected to TalonSRX on CAN
    RemoteTalonSRX = 1,
    /// User Limit switch connected to CANifier
    RemoteCANifier = 2,
    /// Don't use a limit switch
    Deactivated = 3,
}
#[repr(i32)]
/// Remote Limit switch source enum
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "num", derive(FromPrimitive))]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub enum RemoteLimitSwitchSource {
    /// Don't use limit switch, this is the factory default value
    FactoryDefaultOff = 0,
    /// Use Limit switch connected to TalonSRX on CAN
    RemoteTalonSRX = 1,
    /// User Limit switch connected to CANifier
    RemoteCANifier = 2,
    /// Don't use a limit switch
    Deactivated = 3,
}
#[repr(i32)]
/**
 * Choose whether the limit switch is normally
 * open or normally closed
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "num", derive(FromPrimitive))]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub enum LimitSwitchNormal {
    /// Limit Switch is tripped when the circuit is closed
    NormallyOpen = 0,
    /// Limit Switch is tripped when the circuit is open
    NormallyClosed = 1,
    /// Limit switch is disabled
    Disabled = 2,
}

#[repr(i32)]
/// Choose the neutral mode for a motor controller
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "num", derive(FromPrimitive))]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub enum NeutralMode {
    /// Use the NeutralMode that is set in the MC's persistent storage.
    EEPROMSetting = 0,
    /// When commanded to neutral, motor leads are set to high-impedance, allowing mechanism to coast.
    Coast = 1,
    /// When commanded to neutral, motor leads are commonized electrically to reduce motion.
    Brake = 2,
}

#[repr(i32)]
/// Choose the remote sensor source for a motor controller
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "num", derive(FromPrimitive))]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub enum RemoteSensorSource {
    /// Don't use a sensor
    Off = 0,
    /// Use a sensor connected to
    /// a TalonSRX and configured on
    /// the TalonSRX
    TalonSRX_SelectedSensor = 1,
    /// Use a CAN Pigeon's Yaw value
    Pigeon_Yaw = 2,
    /// Use a CAN Pigeon's Pitch value
    Pigeon_Pitch = 3,
    /// Use a CAN Pigeon's Roll value
    Pigeon_Roll = 4,
    /// Use a quadrature sensor
    /// connected to a CANifier
    CANifier_Quadrature = 5,
    /// Use a PWM sensor connected
    /// to CANifier's PWM0
    CANifier_PWMInput0 = 6,
    /// Use a PWM sensor connected
    /// to CANifier's PWM1
    CANifier_PWMInput1 = 7,
    /// Use a PWM sensor connected
    /// to CANifier's PWM2
    CANifier_PWMInput2 = 8,
    /// Use a PWM sensor connected
    /// to CANifier's PWM3
    CANifier_PWMInput3 = 9,
    /// Use the yaw value of a pigeon
    /// connected to a talon over ribbon cable
    GadgeteerPigeon_Yaw = 10,
    /// Use the pitch value of a pigeon
    /// connected to a talon over ribbon cable
    GadgeteerPigeon_Pitch = 11,
    /// Use the roll value of a pigeon
    /// connected to a talon over ribbon cable
    GadgeteerPigeon_Roll = 12,
}

#[repr(i32)]
/// Choose the sensor term for a motor controller
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SensorTerm {
    Sum0 = 0,
    Sum1 = 1,
    Diff0 = 2,
    Diff1 = 3,
}

enum_number! {
    #[repr(i32)]
    #[cfg_attr(feature = "num", derive(FromPrimitive))]
    pub enum VelocityMeasPeriod {
        Period_1Ms = 1,
        Period_2Ms = 2,
        Period_5Ms = 5,
        Period_10Ms = 10,
        Period_20Ms = 20,
        Period_25Ms = 25,
        Period_50Ms = 50,
        Period_100Ms = 100,
    }
}
